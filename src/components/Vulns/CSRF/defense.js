import React, { Component } from "react";

class Defense extends Component {
  render() {
    return (
      <div className="description">
        <h2>Защита от уязвимости</h2>
        <h3>CSRF token</h3>
        <p>
          Для каждой пользовательской сессии генерируется уникальный и
          высокоэнтропийный токен. Токен вставляется в DOM HTML страницы или
          отдается пользователю через API. Пользователь с каждым запросом,
          связанным с какими-либо изменениями, должен отправить токен в
          параметре или в HTTP-заголовке запроса. Так как атакующий не знает
          токен, то классическая CSRF-атака не работает.
        </p>
        <p>
          Токен делается так, чтобы с одной стороны он был отличен от ключа, в
          частности, может быть много токенов для одного ключа, с другой – чтобы
          было легко проверить по токену, сгенерирован ли он на основе данного
          ключа или нет. Для каждого токена нужно дополнительное случайное
          значение, которое называют «соль» salt. Формула вычисления токена:
          <pre class="prettyprint lang-js">
            token = salt + ":" + SHA256(salt + ":" + secret)
          </pre>
          Например: <br/> 1. В сессии хранится secret="abcdef", это значение создаётся
          один раз. <br />
          2. Для нового токена сгенерируем salt, например пусть salt="1234".{" "}
          <br />
          3. token = "1234" + ":" + SHA256("1234" + ":" + "abcdef") =
          "1234:5ad02792a3285252e524ccadeeda3401". <br />
          4. Это значение – с одной стороны, случайное, с другой – имея такой
          token, мы можем взять его первую часть 1234 в качестве salt и, зная
          secret, проверить по формуле, верно ли он вычислен. <br />
          Не зная secret, невозможно сгенерировать token, который сервер
          воспримет как правильный.
        </p>
        <h3>Double submit cookie</h3>
        <p>
          Опять генерируется уникальный и высокоэнтропийный токен для каждой
          пользовательской сессии, но он помещается в куки. Пользователь должен
          в запросе передать одинаковые значения в куках и в параметре запроса.
          Если эти два значения совпадают в куках и в параметре, то считается,
          что это легитимный запрос. Так как атакующий просто так не может
          изменить куки в браузере пользователя, то классическая CSRF-атака не
          работает.
        </p>
        <h3>Content-Type based protection</h3>
        <p>
          Пользователь должен отправить запрос с определенным заголовком
          Content-Type, например, application/json. Так как в браузере через
          HTML форму или XHR API невозможно отправить произвольный Content-Type
          cross-origin, то классическая CSRF-атака опять не работает.
        </p>
        <h3>Referer-based protection</h3>
        <p>
          Пользователь должен отправить запрос с определенным значением
          заголовка Referer. Бэкенд его проверяет, если он неверный, то
          считается, что это CSRF-атака. Так как браузер не может отправить
          произвольный Referer через HTML форму или XHR API, то классическая
          CSRF-атака не работает.
        </p>
        <h3>Password confirmation / websudo</h3>
        <p>
          Пользователь должен подтверждать действие с помощью пароля (или
          секрета). Так как атакующий его не знает, то классическая CSRF-атака
          не работает.
        </p>
        <h3>SameSite Cookies в Chrome, Opera</h3>
        <p>
          Это новая технология, которая призвана защитить от CSRF. В данный
          момент она работает только в двух браузерах (Chrome, Opera). У куки
          устанавливается дополнительный атрибут — samesite, который может иметь
          два значения: lax или strict. Суть технологии в том, что браузер не
          отправляет куки, если запрос осуществляется с другого домена,
          например, с сайта атакующего. Таким образом это опять защищает от
          классической CSRF-атаки.
        </p>
      </div>
    );
  }
}

export default Defense;
