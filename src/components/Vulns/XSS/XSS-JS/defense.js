import React, { Component } from "react";

class Defense extends Component {
  
  render() {
    const regexp = 'replace(/</?[a-z][a-z0-9]*>/gi, "")';
    return (
      <div className="tab">
        <h2 style={this.props.styles.headline}>Защита от уязвимости</h2>
        <h3>Регулярные выражения</h3>
        <p>
          Чтобы не допустить внедрения скрипта через поля ввода, необходимо
          проверять весь пользовательский ввод и фильтровать его, например, с
          помощью регулярных выражений. <br />
          Данное регулярное выражение проверяет введенный пользователем текст и
          убирает из него все теги: <b>{regexp}</b>
        </p>
        <p>
          Для приложений, написанных на PHP, использовать встроенные функции:{" "}
          <br />
          <b>strip_tags()</b> — удаляет из строки все HTML-теги, кроме
          разрешённых. <br />
          <b>htmlspecialchars()</b> — заменяет все спецсимволы на их
          HTML-аналоги.
        </p>
        <p>
          Для приложений, написанных на Node.js, использовать специальные
          плагины, например, Helmet - помогает защитить приложение от некоторых
          широко известных веб-уязвимостей путем соответствующей настройки
          заголовков HTTP.
        </p>
        <h3>Используйте подход «белые списки»</h3>
        <p>
          Подход работает по принципу «что не разрешено, то запрещено». Это
          стандартный механизм валидации полей для проверки всех входных данных,
          включая заголовки, куки, строки запросов, скрытые поля, а также длина
          полей форм, их тип, синтаксис, допустимые символы и другие правила,
          прежде чем принять данные, которые будут сохраненные и отображены на
          сайте. Например, если в поле нужно указать фамилию, необходимо
          разрешить только буквы, дефис и пробелы. Если отклонить все остальное,
          то фамилия д’Арк будет отклонена — лучше отклонить достоверную
          информацию, чем принять вредоносные данные.
          <br /> К сожалению, со своей задачей встроенные фильтры валидации
          данных PHP не справляются, поэтому рекомендуется писать собственные
          фильтры и «допиливать» их по мере необходимости. Таким образом, со
          временем ваши входные методы фильтрации будут усовершенствованы. Стоит
          также не забывать, что существует слишком много типов активного
          содержимого и способов кодирования для обхода подобных фильтров. По
          этой же причине не используйте проверку по «черному списку»
        </p>
        <h3>Использовать Content Security Policy (CSP)</h3>
        <p>
          Это заголовок, который позволяет в явном виде объявить «белый список»
          источников, с которых можно подгружать различные данные, например, JS,
          CSS, изображения и пр. Даже если злоумышленнику удастся внедрить
          скрипт в веб-страницу, он не выполниться, если не будет
          соответствовать разрешенному списку источников.
          <br />
          Для того чтобы воспользоваться CSP, веб-приложение должно через
          HTTP-заголовок «Content-Security-Policy» посылать политику браузеру.
        </p>
        <h3>
          Регулярно проводите анализ безопасности кода и тестирование на
          проникновение
        </h3>
        <p>
          Используйте как ручной, так и автоматизированный подходы. Такие
          инструменты как Nessus, Nikto и OWASP Zed Attack Proxy помогут
          обнаружить уязвимости XSS в вашем веб-приложении.
        </p>
        <h3>Установить флаг HttpOnly.</h3>
        <p>
          Этот флаг делает клиентские куки недоступными через языки сценариев,
          такие как JavaScript.
        </p>
      </div>
    );
  }
}

export default Defense;
