import React, { Component } from "react";
import RaisedButton from "material-ui/RaisedButton";
import TextField from "material-ui/TextField";
import { Tabs, Tab } from "material-ui/Tabs";
import {Card, CardActions, CardHeader, CardText} from 'material-ui/Card';
import xss_screen from '../../../images/xss_screen.png'
import './xss.css'
import user from '../../../images/user.png'
import xss from '../../../images/xss.png'

class XSS extends Component {
  constructor(props) {
    super(props);
    this.state = {
      inputValue: "",
      dangerousScript: "",
      inputs: [
        "Всем привет! Как пропатчить KDE под FreeBSD?",
        "@username, Довольно давно существует KDE FreeBSD Initiative — ее команда специально занимается обеспечением высокого уровня совместимости между FreeBSD и KDE. Они обсуждают патчи, ищут ошибки и предлагают новые возможности. Присоединяйтесь — freebsd.kde.org",
        "Какой инструмент можете подкинуть для выполнения статического анализа различной бинарщины?",
        "Коллеги, узнал, что в принтерах стоит так называемый форматер. Что это за зверь?"
      ],
      regexp: 'replace(/<\/?[a-z][a-z0-9]*>/gi, "")',
      
    };
    this.putValue = this.putValue.bind(this);
    this.refreshValue = this.refreshValue.bind(this);
    this.getScript = this.getScript.bind(this);
  }

  componentDidMount(){
    document.cookie = 'userID=p25M98tGkfEWGR2'
    localStorage.name = 'Alexey Kabanov';
    localStorage.age = '23';
    localStorage.location = 'Moscow';
  }

  getScript() {
    if(this.state.inputValue.indexOf('<script>') > -1){
      const script = document.createElement("script");
      script.innerHTML = this.state.dangerousScript;
      script.async = true;
      document.body.appendChild(script);
    }
  }

  refreshValue(event) {
    this.setState({
      dangerousScript: event.target.value.replace(/<\/?[a-z][a-z0-9]*>/gi, ""),
      inputValue: event.target.value
    });
  }

  putValue() {
    this.setState({
      inputs: [...this.state.inputs, this.state.inputValue]
    });
  }


  
  render() {

    const styles = {
      headline: {
        fontSize: 24,
        paddingTop: 16,
        marginBottom: 12,
        fontWeight: 400
      }
    };

    const script1 = `<script>alert("cookie: "+document.cookie)</script>`
    const script2 = `http://site.ru/catalog?p=<script>alert("cookie: "+document.cookie)</script>`


    return (
      <div className="vuln">
        <Tabs>
          <Tab label="Описание">
            <div className="vulnInner">
              <h2 style={styles.headline}>XSS атака</h2>
              
                   <img src={xss} alt="" className="xss-image" />
              
                   <p> XSS (межсайтовый скриптинг) – одна из разновидностей атак на веб-системы, которая подразумевает внедрение вредоносного кода на определенную страницу сайта и взаимодействие этого кода с удаленным сервером злоумышленников при открытии страницы пользователем.</p>

                   <p> Термин с английского расшифровывается как Cross-Site Scripting, но при этом получил аббревиатуру XSS, чтобы не было путаницы с CSS (каскадные таблицы стилей). </p>

                   <h2> Как работает межсайтовый скриптинг </h2>
                   <p> Основная цель межсайтового скриптинга – кража cookies пользователей при помощи встроенного на сервере скрипта с дальнейшей выборкой необходимых данных и использованием их для последующих атак и взломов. Злоумышленник осуществляет атаку пользователей не напрямую, а с использованием уязвимостей веб-сайта, который посещают жертвы, и внедряет специальный JavaScript. В браузере у пользователей этот код отображается как единая часть сайта. При этом посещаемый ресурс по факту является соучастником XSS-атаки. </p>

                    <p> Если сравнивать с SQL-инъекциями, то XSS безопасен для сервера, но несет угрозу для пользователей зараженного ресурса или страницы. Однако, если к злоумышленнику попадут cookies администратора, можно получить доступ к панели управления сайтом и его содержимому. </p>

                   <h2> Методика атаки через XSS </h2>
                   <p> Запуск вредоносного кода JavaScript возможен только в браузере жертвы, поэтому сайт, на который зайдет пользователь, должен иметь уязвимость к XSS. Для совершения атаки злоумышленник изначально проверяет ресурсы на наличие уязвимостей через XSS, используя автоматизированные скрипты или ручной режим поиска. Обычно это стандартные формы, которые могут отправлять и принимать запросы (комментарии, поиск, обратная связь). </p>

                    <p> Проводится полный сбор страниц с формами ввода, и каждая сканируется на наличие уязвимостей. Например, у нас есть страница «Поиск» на сайте. Для проверки уязвимости XSS достаточно ввести запрос: <b> &lt;script&gt;alert("cookie: " + document.cookie)&lt;/script&gt; </b> </p>


                    <p> Если на экране появится уведомление, значит вы обнаружили брешь в безопасности. В противном случае система отобразит вам страницу с результатами поиска. Основные популярные CMS уже давно лишились подобных проблем, но из-за возможности расширения функционала за счет модулей и плагинов, создаваемых сторонними разработчиками, шансы на использование уязвимостей XSS возрастают в разы, особенно в Joomla, DLE, Bitrix, Wordpress. Чаще всего XSS-уязвимости проверяются в браузере Internet Explorer. </p>

                    <p>Еще один возможный вариант поиска – использование страниц, которые обрабатывают GET-запросы. Допустим, у нас есть ссылка вида: http://site.ru/catalog?p=8 </p>

                    <p>В адресной строке вместо идентификатора (8) добавляем скрипт – 
                      <pre class="prettyprint lang-js">
                        {script1} 
                      </pre>
                      В результате чего получаем ссылку такого вида: 
                      <pre class="prettyprint lang-js">
                        {script2}
                      </pre> 
                     </p>

                    <p>Если страница имеет уязвимости XSS, на экране появится уведомление такого же плана, как и в первом случае.</p>

                   <p> Для поиска «дыр» на сайте существует огромное количество готовых скриптов и запросов, и если ни один из них не подходит, значит ресурс надежно защищен от подобных атак. </p>

                    <h2>Эксплуатация</h2>
                    <p>
                      Во второй вкладке данного приложения можно проэксплуатировать атаку XSS. 
                      Самый простой способ - это ввести в окно ввода скрипт, показывающий Cookie браузера:
                      <b> &lt;script&gt;alert("cookie: " + document.cookie)&lt;/script&gt; </b> 
                      После этого появится окно с Cookie браузера.
                    </p>
                    <img src={xss_screen} alt="" className="xss-image" />
                    <p>
                    Cookie служат для сохранения учетных данных сайта на компьютере посетителя. <br/>
                    Если вы зарегистрировались на сайте под ником 'username123', то сайт сохранил у вас на компьютере файл с cookies, где закодированы ваши данные. <br/>
                    А если вы администратор и у вас есть доступ к сайту, а я - пользователь, который украл у вас cookies, то я могу зайти на сайт, и сайт меня определяет как 'admin' - у меня будут полные администраторские права.
                    </p>
                    <p>Если информация из полей ввода хранится в базе данных (блог, чат и т.д.),
                      то злоумышленник может отправить в базу данных скрипт, 
                      который будет красть cookies пользователей и отправлять себе на почту.
                      Т.к. все записи из БД выводятся для всех пользователей на страницу,
                      то когда пользователь зайдет на сайт, этот скрипт загрузится для него из БД
                      и сразу отправит cookies пользователя на почту злоумышленника.
                    </p>
            </div>
          </Tab>
          <Tab label="Эксплуатация">
            <div>
              <header className="App-header">

                <ul>
                  {this.state.inputs.map(item => (
                    <Card>
                      <CardHeader
                        title="Username"
                        subtitle="Пользователь"
                        avatar={user}
                        className="userAvatar"
                      />
                      
                      <CardText >
                        {item}
                      </CardText>
                    </Card>
                  ))}
                </ul>
                <TextField
                  hintText="Ваше сообщение"
                  floatingLabelText="Введите сообщение"
                  onChange={this.refreshValue}
                  className="xss__input"
                />
                <RaisedButton
                  className="eventButton"
                  label="Отправить"
                  primary={true}
                  onClick={() => {this.putValue(); this.getScript()}}
                />
              </header>
            </div>
          </Tab>
          <Tab label="Защита">
            <div className="tab">
              <h2 style={styles.headline}>Защита от уязвимости</h2>
              <h3>Регулярные выражения</h3>
              <p>Чтобы не допустить внедрения скрипта через поля ввода, необходимо проверять 
                весь пользовательский ввод и фильтровать его, например, с помощью регулярных выражений. <br/>
                Данное регулярное выражение проверяет введенный пользователем текст
                и убирает из него все теги: <b>{this.state.regexp}</b>
              </p>
              <p>Для приложений, написанных на PHP, использовать встроенные функции: <br/>
                <b>strip_tags()</b> — удаляет из строки все HTML-теги, кроме разрешённых. <br/>
                <b>htmlspecialchars()</b> — заменяет все спецсимволы на их HTML-аналоги.
              </p>
              <p>Для приложений, написанных на Node.js, использовать специальные
                плагины, например, Helmet - помогает защитить приложение от некоторых 
                широко известных веб-уязвимостей путем соответствующей настройки заголовков HTTP.
              </p>
              <h3>Используйте подход «белые списки»</h3>
              <p>
              Подход работает по принципу «что не разрешено, то запрещено». Это стандартный механизм валидации полей для проверки всех входных данных, включая заголовки, куки, строки запросов, скрытые поля, а также длина полей форм, их тип, синтаксис, допустимые символы и другие правила, прежде чем принять данные, которые будут сохраненные и отображены на сайте. Например, если в поле нужно указать фамилию, необходимо разрешить только буквы, дефис и пробелы. Если отклонить все остальное, то фамилия д’Арк будет отклонена — лучше отклонить достоверную информацию, чем принять вредоносные данные.
              <br/> К сожалению, со своей задачей встроенные фильтры валидации данных PHP не справляются, поэтому рекомендуется писать собственные фильтры и «допиливать» их по мере необходимости. Таким образом, со временем ваши входные методы фильтрации будут усовершенствованы. Стоит также не забывать, что существует слишком много типов активного содержимого и способов кодирования для обхода подобных фильтров. По этой же причине не используйте проверку по «черному списку»
              </p>
              <h3>Использовать Content Security Policy (CSP)</h3>
              <p>Это заголовок, который позволяет в явном виде объявить «белый список» источников, с которых можно подгружать различные данные, например, JS, CSS, изображения и пр. Даже если злоумышленнику удастся внедрить скрипт в веб-страницу, он не выполниться, если не будет соответствовать разрешенному списку источников.
                <br/>Для того чтобы воспользоваться CSP, веб-приложение должно через HTTP-заголовок «Content-Security-Policy» посылать политику браузеру.</p>
              <h3>Регулярно проводите анализ безопасности кода и тестирование на проникновение</h3>  
              <p>Используйте как ручной, так и автоматизированный подходы. Такие инструменты как Nessus, Nikto и OWASP Zed Attack Proxy помогут обнаружить уязвимости XSS в вашем веб-приложении.</p>
              <h3>Установить флаг HttpOnly.</h3>
              <p>Этот флаг делает клиентские куки недоступными через языки сценариев, такие как JavaScript.</p>
            </div>
          </Tab>
        </Tabs>
      </div>
    );
  }
}

export default XSS;
